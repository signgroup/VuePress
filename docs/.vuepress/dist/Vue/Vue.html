<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2020Vue经典面试题总结 | 初见博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/vuepress/favicon.ico">
    <meta name="description" content="初见博客">
    <link rel="preload" href="/vuepress/assets/css/0.styles.912360c0.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.756c7184.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.8c1e7ee0.js" as="script"><link rel="preload" href="/vuepress/assets/js/6.59433abe.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.18059584.js"><link rel="prefetch" href="/vuepress/assets/js/11.c9bd139e.js"><link rel="prefetch" href="/vuepress/assets/js/12.147a2e37.js"><link rel="prefetch" href="/vuepress/assets/js/13.5b462613.js"><link rel="prefetch" href="/vuepress/assets/js/14.acde6fb7.js"><link rel="prefetch" href="/vuepress/assets/js/15.cba6a481.js"><link rel="prefetch" href="/vuepress/assets/js/3.9e901989.js"><link rel="prefetch" href="/vuepress/assets/js/4.5c2c6741.js"><link rel="prefetch" href="/vuepress/assets/js/5.5c3548e6.js"><link rel="prefetch" href="/vuepress/assets/js/7.bc38efe5.js"><link rel="prefetch" href="/vuepress/assets/js/8.0ff25655.js"><link rel="prefetch" href="/vuepress/assets/js/9.928b4098.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.912360c0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><img src="/vuepress/img/logo.png" alt="初见博客" class="logo"> <span class="site-name can-hide">初见博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/Vue/Vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/vuepress/foo/" class="nav-link">
  Foo
</a></div><div class="nav-item"><a href="/vuepress/bar/" class="nav-link">
  Bar
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="select menu" class="dropdown-title"><span class="title">select</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/select/select1.html" class="nav-link">
  select1
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/select/select2.html" class="nav-link">
  select2
</a></li></ul></div></div><div class="nav-item"><a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/Vue/Vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/vuepress/foo/" class="nav-link">
  Foo
</a></div><div class="nav-item"><a href="/vuepress/bar/" class="nav-link">
  Bar
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="select menu" class="dropdown-title"><span class="title">select</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/select/select1.html" class="nav-link">
  select1
</a></li><li class="dropdown-item"><!----> <a href="/vuepress/select/select2.html" class="nav-link">
  select2
</a></li></ul></div></div><div class="nav-item"><a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress/Vue/Vue.html" aria-current="page" class="active sidebar-link">2020Vue经典面试题总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#什么是mvvm？" class="sidebar-link">什么是MVVM？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="sidebar-link">MVVM和MVC区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue的优点是什么？" class="sidebar-link">vue的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue-js的两个核心是什么？" class="sidebar-link">vue.js的两个核心是什么？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#组件之间的传值？" class="sidebar-link">组件之间的传值？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#路由之间跳转" class="sidebar-link">路由之间跳转</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？" class="sidebar-link">vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue如何实现按需加载配合webpack设置" class="sidebar-link">vue如何实现按需加载配合webpack设置</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vuex面试相关" class="sidebar-link">vuex面试相关</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#v-show和v-if指令的共同点和不同点" class="sidebar-link">v-show和v-if指令的共同点和不同点</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#如何让css只在当前组件中起作用" class="sidebar-link">如何让CSS只在当前组件中起作用</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#keep-alive-keep-alive-的作用是什么" class="sidebar-link">&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue中引入组件的步骤" class="sidebar-link">Vue中引入组件的步骤?</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#指令v-el的作用是什么" class="sidebar-link">指令v-el的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#在vue中使用插件的步骤" class="sidebar-link">在Vue中使用插件的步骤</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#请列举出3个vue中常用的生命周期钩子函数" class="sidebar-link">请列举出3个Vue中常用的生命周期钩子函数</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#active-class是哪个组件的属性？" class="sidebar-link">active-class是哪个组件的属性？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#怎么定义vue-router的动态路由以及如何获取传过来的动态参数？" class="sidebar-link">怎么定义vue-router的动态路由以及如何获取传过来的动态参数？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue-router有哪几种导航钩子？" class="sidebar-link">vue-router有哪几种导航钩子？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#生命周期相关面试题" class="sidebar-link">生命周期相关面试题</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#说出至少4种vue当中的指令和它的用法？" class="sidebar-link">说出至少4种vue当中的指令和它的用法？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vue-loader是什么？使用它的用途有哪些？" class="sidebar-link">vue-loader是什么？使用它的用途有哪些？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="sidebar-link">scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#为什么使用key？" class="sidebar-link">为什么使用key？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#为什么避免-v-if-和-v-for-用在一起" class="sidebar-link">为什么避免 v-if 和 v-for 用在一起</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#vnode是什么？虚拟-dom是什么？" class="sidebar-link">VNode是什么？虚拟 DOM是什么？</a></li><li class="sidebar-sub-header"><a href="/vuepress/Vue/Vue.html#动态绑定class有几种方式？" class="sidebar-link">动态绑定Class有几种方式？</a></li></ul></li><li><a href="/vuepress/Vue/contact.html" class="sidebar-link">contact1</a></li><li><a href="/vuepress/Vue/about.html" class="sidebar-link">about</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_2020vue经典面试题总结"><a href="#_2020vue经典面试题总结" class="header-anchor">#</a> 2020Vue经典面试题总结</h1> <h2 id="什么是mvvm？"><a href="#什么是mvvm？" class="header-anchor">#</a> 什么是MVVM？</h2> <p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p> <p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p> <p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p> <h2 id="mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？"><a href="#mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="header-anchor">#</a> MVVM和MVC区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h2> <p>MVC和MVVM其实区别并不大。都是一种设计思想。主要就是MVC中Controller演变成MVVM中的ViewModel。MVVM主要解决了MVC中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p> <p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。</p> <p>场景：数据操作比较多的场景，更加便捷</p> <h4 id="mvc"><a href="#mvc" class="header-anchor">#</a> MVC</h4> <ul><li>M：模型层</li> <li>V：视图层</li> <li>P：控制器层</li></ul> <h4 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h4> <ul><li>M：负责存储数据（模型层）</li> <li>V：负责显示数据（视图层）</li> <li>VM：Vue自带的层（内置）MVVM 不用关注ViewModel如何实现的，它是Vue内置的最重的是M层，dom操作被极大简化，使用MVVM是面向数据进行编程</li></ul> <h2 id="vue的优点是什么？"><a href="#vue的优点是什么？" class="header-anchor">#</a> vue的优点是什么？</h2> <h4 id="_1、轻量级框架"><a href="#_1、轻量级框架" class="header-anchor">#</a> 1、轻量级框架</h4> <p>只关注视图层,是一个构建数据的视图集合,大小只有几十kb</p> <p>Vue.js通过简洁的API提供高效的数据绑定和灵活的组件系统</p> <h4 id="_2、简单易学"><a href="#_2、简单易学" class="header-anchor">#</a> 2、简单易学</h4> <p>国人开发,中文文档,不存在语言障碍,易于理解和学习</p> <h4 id="_3、双向数据绑定"><a href="#_3、双向数据绑定" class="header-anchor">#</a> 3、双向数据绑定</h4> <p>也就是所谓的响应式数据绑定。这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出同步的响应。</p> <p>也就是说，vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，就是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。</p> <p>这也就是vue.js最大的优点，通过MVVM思想实现数据的双向绑定，让开发者不用再操作dom对象，有更多的时间去思考业务逻辑。</p> <h4 id="_4、组件化"><a href="#_4、组件化" class="header-anchor">#</a> 4、组件化</h4> <p>在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。</p> <p>Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p> <h4 id="_5、视图-数据-结构分离"><a href="#_5、视图-数据-结构分离" class="header-anchor">#</a> 5、视图,数据,结构分离</h4> <p>使数据的更改更为简单,不需要进行逻辑代码的修改,只需要操作数据就能完成相关操作</p> <h4 id="_6、虚拟dom"><a href="#_6、虚拟dom" class="header-anchor">#</a> 6、虚拟DOM</h4> <p>现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。</p> <p>而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。</p> <h4 id="_7、运行速度更快"><a href="#_7、运行速度更快" class="header-anchor">#</a> 7、运行速度更快</h4> <p>像比较与react而言,同样都是操作虚拟dom,就性能而言,vue存在很大的优势</p> <h2 id="vue-js的两个核心是什么？"><a href="#vue-js的两个核心是什么？" class="header-anchor">#</a> vue.js的两个核心是什么？</h2> <p>数据驱动和组件化。</p> <h2 id="组件之间的传值？"><a href="#组件之间的传值？" class="header-anchor">#</a> 组件之间的传值？</h2> <p>父组件与子组件传值</p> <p>父组件通过标签上面定义传值</p> <p>子组件通过props方法接受数据</p> <p>子组件向父组件传递数据</p> <p>子组件通过$emit方法传递参数</p> <h2 id="路由之间跳转"><a href="#路由之间跳转" class="header-anchor">#</a> 路由之间跳转</h2> <p>声明式（标签跳转） 编程式（ js跳转）</p> <h2 id="vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？"><a href="#vue-cli中怎样使用自定义的组件？有遇到过哪些问题吗？" class="header-anchor">#</a> vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？</h2> <p>第一步：在components目录新建你的组件文件（indexPage.vue），script一定要export default {}</p> <p>第二步：在需要用的页面（组件）中导入：import indexPage from ‘@/components/indexPage.vue’</p> <p>第三步：注入到vue的子组件的components属性上面,components:{indexPage}</p> <p>第四步：在template视图view中使用，</p> <p>例如有indexPage命名，使用的时候则index-page</p> <h2 id="vue如何实现按需加载配合webpack设置"><a href="#vue如何实现按需加载配合webpack设置" class="header-anchor">#</a> vue如何实现按需加载配合webpack设置</h2> <p>webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。</p> <p>不进行页面按需加载引入方式：import home from ‘…/…/common/home.vue’</p> <p>进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require(’…/…/common/home.vue’)))</p> <h2 id="vuex面试相关"><a href="#vuex面试相关" class="header-anchor">#</a> vuex面试相关</h2> <p>（1）vuex是什么？怎么使用？哪种功能场景使用它？</p> <p>vue框架中状态管理。在main.js引入store，注入。新建一个目录store，…… export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p> <p>（2）vuex有哪几种属性？</p> <p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p> <p>vuex的State特性</p> <p>A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data</p> <p>B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新</p> <p>C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p> <p>vuex的Getter特性</p> <p>A、getters 可以对State进行计算操作，它就是Store的计算属性</p> <p>B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用</p> <p>C、 如果一个状态只在一个组件内使用，是可以不用getters</p> <p>vuex的Mutation特性</p> <p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p> <p>（3）不用Vuex会带来什么问题？</p> <p>可维护性会下降，想修改数据要维护三个地方；</p> <p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p> <p>增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。</p> <h2 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="header-anchor">#</a> v-show和v-if指令的共同点和不同点</h2> <h4 id="相同点"><a href="#相同点" class="header-anchor">#</a> 相同点</h4> <p>两者都是在判断DOM节点是否要显示。</p> <h4 id="不同点"><a href="#不同点" class="header-anchor">#</a> 不同点</h4> <ul><li>实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。  v-show只是在修改元素的css样式，也就是display的属性值，元素始终在Dom树上。</li> <li>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；  v-show只是简单的基于css切换；</li> <li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译； v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留；</li> <li>性能消耗：v-if有更高的切换消耗，不适合做频繁的切换；  v-show有更高的初始渲染消耗，适合做频繁的额切换；</li></ul> <h2 id="如何让css只在当前组件中起作用"><a href="#如何让css只在当前组件中起作用" class="header-anchor">#</a> 如何让CSS只在当前组件中起作用</h2> <p>将当前组件的</p> <h2 id="keep-alive-keep-alive-的作用是什么"><a href="#keep-alive-keep-alive-的作用是什么" class="header-anchor">#</a> <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的作用是什么?</h2> <p>包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。</p> <h2 id="vue中引入组件的步骤"><a href="#vue中引入组件的步骤" class="header-anchor">#</a> Vue中引入组件的步骤?</h2> <p>1）采用ES6的import … from …语法或CommonJS的require()方法引入组件</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> HelloWorld <span class="token keyword">from</span> <span class="token string">'HelloWorld'</span><span class="token punctuation">;</span>
</code></pre></div><p>2）对组件进行注册,代码如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>components<span class="token operator">:</span><span class="token punctuation">{</span>HelloWorld<span class="token punctuation">}</span>
</code></pre></div><p>3）在html中引用这个组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hello-world</span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="指令v-el的作用是什么"><a href="#指令v-el的作用是什么" class="header-anchor">#</a> 指令v-el的作用是什么?</h2> <p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p> <h2 id="在vue中使用插件的步骤"><a href="#在vue中使用插件的步骤" class="header-anchor">#</a> 在Vue中使用插件的步骤</h2> <p>采用ES6的import … from …语法或CommonJSd的require()方法引入插件</p> <p>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</p> <h2 id="请列举出3个vue中常用的生命周期钩子函数"><a href="#请列举出3个vue中常用的生命周期钩子函数" class="header-anchor">#</a> 请列举出3个Vue中常用的生命周期钩子函数</h2> <p>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</p> <p>mounted: el被新创建的 vm.el替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当mounted被调用时vm. el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.el替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当mounted被调用时vm.el 也在文档内。</p> <p>activated: keep-alive组件激活时调用</p> <h2 id="active-class是哪个组件的属性？"><a href="#active-class是哪个组件的属性？" class="header-anchor">#</a> active-class是哪个组件的属性？</h2> <p>vue-router模块的router-link组件。</p> <h2 id="怎么定义vue-router的动态路由以及如何获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由以及如何获取传过来的动态参数？" class="header-anchor">#</a> 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？</h2> <p>在router目录下的index.js文件中，对path属性加上/:id。</p> <p>使用router对象的params.id。</p> <h2 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="header-anchor">#</a> vue-router有哪几种导航钩子？</h2> <p>三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。</p> <p>第二种：组件内的钩子；</p> <p>第三种：单独路由独享组件</p> <h2 id="生命周期相关面试题"><a href="#生命周期相关面试题" class="header-anchor">#</a> 生命周期相关面试题</h2> <p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p> <p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。</p> <p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p> <p>更新前/后：当data变化时，会触发beforeUpdate和updated方法。</p> <p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p> <p>（1）、什么是vue生命周期</p> <p>答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p> <p>（2）、vue生命周期的作用是什么</p> <p>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p> <p>（3）、vue生命周期总共有几个阶段</p> <p>答：可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p> <p>（4）、第一次页面加载会触发哪几个钩子</p> <p>答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p> <p>（5）、DOM 渲染在 哪个周期中就已经完成</p> <p>答：DOM 渲染在 mounted 中就已经完成了。</p> <p>（6）、简单描述每个周期具体适合哪些场景</p> <p>答：生命周期钩子的一些使用方法：</p> <p>beforecreate : 可以在这加个loading事件，在加载实例时触发</p> <p>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</p> <p>mounted : 挂载元素，获取到DOM节点</p> <p>updated : 如果对数据统一处理，在这里写上相应函数</p> <p>beforeDestroy : 可以做一个确认停止事件的确认框</p> <p>nextTick : 更新数据后立即操作dom</p> <h2 id="说出至少4种vue当中的指令和它的用法？"><a href="#说出至少4种vue当中的指令和它的用法？" class="header-anchor">#</a> 说出至少4种vue当中的指令和它的用法？</h2> <p>v-if：判断是否隐藏；v-for：数据循环；v-bind:class：绑定一个属性；v-model：实现双向绑定</p> <p>Vue如何创建自定义指令？</p> <h2 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="header-anchor">#</a> vue-loader是什么？使用它的用途有哪些？</h2> <p>解析.vue文件的一个加载器。</p> <p>用途：js可以写es6、style样式可以scss或less、template可以加jade等</p> <h2 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="header-anchor">#</a> scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h2> <p>答：css的预编译。</p> <p>使用步骤：</p> <p>第一步：先装css-loader、node-loader、sass-loader等加载器模块</p> <p>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</p> <p>第三步：在同一个文件，配置一个module属性</p> <p>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</p> <p>特性:</p> <p>可以用变量，例如（$变量名称=值）；</p> <p>可以用混合器，例如（）</p> <p>可以嵌套</p> <h2 id="为什么使用key？"><a href="#为什么使用key？" class="header-anchor">#</a> 为什么使用key？</h2> <p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p> <h2 id="为什么避免-v-if-和-v-for-用在一起"><a href="#为什么避免-v-if-和-v-for-用在一起" class="header-anchor">#</a> 为什么避免 v-if 和 v-for 用在一起</h2> <p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。</p> <h2 id="vnode是什么？虚拟-dom是什么？"><a href="#vnode是什么？虚拟-dom是什么？" class="header-anchor">#</a> VNode是什么？虚拟 DOM是什么？</h2> <p>Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。</p> <h2 id="动态绑定class有几种方式？"><a href="#动态绑定class有几种方式？" class="header-anchor">#</a> 动态绑定Class有几种方式？</h2> <h4 id="对象方法"><a href="#对象方法" class="header-anchor">#</a> 对象方法</h4> <p>-最简单的绑定（这里的active加不加单引号都可以，以下也一样都能渲染）</p> <div class="language- extra-class"><pre class="language-text"><code>:class=&quot;{ 'active': isActive }&quot;
判断是否绑定一个active
:class=&quot;{'active':isActive==-1}&quot;
或者
:class=&quot;{'active':isActive==index}&quot;

绑定并判断多个
第一种（用逗号隔开）
:class=&quot;{ 'active': isActive, 'sort': isSort }&quot;
第二种（放在data里面）
//也可以把后面绑定的对象写在一个变量放在data里面，可以变成下面这样
:class=&quot;classObject&quot;
data() {
  return {
    classObject:{ active: true, sort:false }
  }
}
第三种（使用computed属性）
:class=&quot;classObject&quot;
data() {
  return {
    isActive: true,
    isSort: false
  }
},
computed: {
  classObject: function () {
    return {
      active: this.isActive,
      sort:this.isSort
    }
  }
}
</code></pre></div><h4 id="数组方法"><a href="#数组方法" class="header-anchor">#</a> 数组方法</h4> <p>1)单纯数组</p> <div class="language-html extra-class"><pre class="language-html"><code>:class=&quot;[isActive,isSort]&quot;
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span><span class="token punctuation">{</span>
    isActive<span class="token operator">:</span><span class="token string">'active'</span><span class="token punctuation">,</span>
    isSort<span class="token operator">:</span><span class="token string">'sort'</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2)数组与三元运算符结合判断选择需要的class</p> <p>注意：三元运算符后面的“：”两边的class需要加上单引号，否则不能正确渲染</p> <div class="language- extra-class"><pre class="language-text"><code>:class=&quot;[isActive?'active':'']&quot;
或者
:class=&quot;[isActive==1?'active':'']&quot;
或者
:class=&quot;[isActive==index?'active':'']&quot;
或者
:class=&quot;[isActive==index?'active':'otherActiveClass']&quot;
</code></pre></div><h4 id="数组对象结合动态判断"><a href="#数组对象结合动态判断" class="header-anchor">#</a> <font color="#00f">数组对象</font>结合动态判断</h4> <p>前面这个active在对象里面可以不加单引号，后面这个sort要加单引号</p> <div class="language- extra-class"><pre class="language-text"><code>:class=&quot;[{ active: isActive }, 'sort']&quot;
或者
:class=&quot;[{ active: isActive==1 }, 'sort']&quot;
或者
:class=&quot;[{ active: isActive==index }, 'sort']&quot;
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/vuepress/Vue/contact.html">
        contact1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.756c7184.js" defer></script><script src="/vuepress/assets/js/2.8c1e7ee0.js" defer></script><script src="/vuepress/assets/js/6.59433abe.js" defer></script>
  </body>
</html>
